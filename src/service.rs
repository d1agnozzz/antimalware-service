

use std::ffi::{OsString};
use std::time::Duration;
use std::sync::mpsc;

use custom_error::custom_error;
use windows_service::{service_dispatcher, Error, Result};

use windows_service::service_manager::{ServiceManager, ServiceManagerAccess};

use windows_service::service::{
    ServiceAccess, ServiceControl, ServiceControlAccept, ServiceDependency, ServiceErrorControl,
    ServiceExitCode, ServiceInfo, ServiceStartType, ServiceState, ServiceStatus, ServiceType,
};

use windows_service::service_control_handler::{self, ServiceControlHandlerResult};

pub const SERVICE_NAME: &str = "antimalware_service_mtuci";
pub const SERVICE_DISPLAY_NAME: &str = "Antimalware Service MTUCI";
const SERVICE_TYPE: ServiceType = ServiceType::OWN_PROCESS;

define_windows_service!(ffi_service_main, service_main);


pub(crate) fn service_main(arguments: Vec<OsString>) {
    // The entry point where execution will start on a background thread after a call to
    // `service_dispatcher::start` from `main`.
    if let Err(_e) = run_service(arguments) {
        // Handle errors in some way.
    }
}

fn run_service(arguments: Vec<OsString>) -> Result<()> {
    let (shutdown_tx, shutdown_rx) = mpsc::channel();

    let event_handler = move |control_event| -> ServiceControlHandlerResult {
        match control_event {
            ServiceControl::Stop => {
                // Handle stop event and return control back to the system.
                shutdown_tx.send(()).unwrap();
                ServiceControlHandlerResult::NoError
            }
            // All services must accept Interrogate even if it's a no-op.
            ServiceControl::Interrogate => ServiceControlHandlerResult::NoError,
            _ => ServiceControlHandlerResult::NotImplemented,
        }
    };

    // Register system service event handler
    let status_handle = service_control_handler::register(SERVICE_NAME, event_handler)?;

    let running_status = ServiceStatus {
        // Should match the one from system service registry
        service_type: SERVICE_TYPE,
        // The new state
        current_state: ServiceState::Running,
        // Accept stop events when running
        controls_accepted: ServiceControlAccept::STOP,
        // Used to report an error when starting or stopping only, otherwise must be zero
        exit_code: ServiceExitCode::Win32(0),
        // Only used for pending states, otherwise must be zero
        checkpoint: 0,
        // Only used for pending states, otherwise must be zero
        wait_hint: Duration::default(),
        // Unused for setting status
        process_id: None,
    };

    // Tell the system that the service is running now
    status_handle.set_service_status(running_status)?;

    loop {
        match shutdown_rx.recv_timeout(std::time::Duration::from_secs(1)) {
            Ok(_) | Err(mpsc::RecvTimeoutError::Disconnected) => break,
            Err(mpsc::RecvTimeoutError::Timeout) => (),
        }
    }


    let stopped_status = ServiceStatus {
        // Should match the one from system service registry
        service_type: SERVICE_TYPE,
        // The new state
        current_state: ServiceState::Stopped,
        // Accept stop events when running
        controls_accepted: ServiceControlAccept::empty(),
        // Used to report an error when starting or stopping only, otherwise must be zero
        exit_code: ServiceExitCode::Win32(0),
        // Only used for pending states, otherwise must be zero
        checkpoint: 0,
        // Only used for pending states, otherwise must be zero
        wait_hint: Duration::default(),
        // Unused for setting status
        process_id: None,
    };

    status_handle.set_service_status(stopped_status)?;

    // Do some work

    Ok(())
}

fn uninstall_service() -> windows_service::Result<()> {
    let manager_access = ServiceManagerAccess::CONNECT | ServiceManagerAccess::CREATE_SERVICE;
    
    let service_manager = ServiceManager::local_computer(None::<&str>, manager_access)?;

    let service = service_manager.open_service(SERVICE_NAME, ServiceAccess::all())?;
    service.delete()?;

    if service.query_status()?.current_state != ServiceState::Stopped {
        service.stop()?;
    }

    drop(service);

    // Win32 API does not give us a way to wait for service deletion.
    // To check if the service is deleted from the database, we have to poll it ourselves.
    use windows_sys::Win32::Foundation::ERROR_SERVICE_DOES_NOT_EXIST;

    let start = std::time::Instant::now();
    let timeout = Duration::from_secs(5);
    while start.elapsed() < timeout {
        if let Err(windows_service::Error::Winapi(e)) =
            service_manager.open_service("ping_service", ServiceAccess::QUERY_STATUS)
        {
            if e.raw_os_error() == Some(ERROR_SERVICE_DOES_NOT_EXIST as i32) {
                println!("{SERVICE_NAME} is deleted.");
                return Ok(());
            }
        }
        std::thread::sleep(Duration::from_secs(1));
    }
    println!("{SERVICE_NAME} is marked for deletion.");

    Ok(())

}

fn install_service() -> windows_service::Result<()> {
    
    let manager_access = ServiceManagerAccess::CONNECT | ServiceManagerAccess::CREATE_SERVICE;
    
    let service_manager = ServiceManager::local_computer(None::<&str>, manager_access)?;
    
    let service_binary_path = std::env::current_exe().unwrap();
    
    let service_info = ServiceInfo {
        name: OsString::from(SERVICE_NAME),
        display_name: OsString::from(SERVICE_DISPLAY_NAME),
        service_type: SERVICE_TYPE,
        start_type: ServiceStartType::OnDemand,
        error_control: ServiceErrorControl::Normal,
        executable_path: service_binary_path,
        launch_arguments: vec![OsString::from("launch")],
        dependencies: Vec::<ServiceDependency>::new(),
        account_name: None,
        account_password: None,
    };

    let mut service_result = service_manager.create_service(&service_info, ServiceAccess::all());

    // if already exists, update config
    if let Err(Error::Winapi(_)) = service_result {
        service_result = service_manager.open_service(SERVICE_NAME, ServiceAccess::all());
        let service = service_result.unwrap();
        
        service.change_config(&service_info)?;
        println!("Changed config!");
        // service.start(&[OsStr::new("")])?;
        // println!("Started!");
        
    }
    
    println!("Service successfully installed!");
    Ok(())
}

custom_error! {pub ProcessError
    WrongArguments = "No command was specified",
    ServiceError{source: windows_service::Error} = "Service error happened"
}

pub fn process_service(args: Option<String>) -> std::result::Result<(), ProcessError> {

    let command = args.ok_or(ProcessError::WrongArguments)?;


    match &command[..] {
        "install" => {
            if let Err(e) = install_service(){
                return Err(ProcessError::ServiceError { source: e });
            } 
        }
        "uninstall" => {
            if let Err(e) = uninstall_service() {
                return Err(ProcessError::ServiceError { source:e });
            } 
        }
        "launch" => service_dispatcher::start(SERVICE_NAME, ffi_service_main)?,

        _ => return Err(ProcessError::WrongArguments)
    };

    // Register generated `ffi_service_main` with the system and start the service, blocking
    // this thread until the service is stopped.

    Ok(())
}
