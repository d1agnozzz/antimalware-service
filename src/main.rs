#[macro_use]
extern crate windows_service;

use std::ffi::OsString;
use windows_service::{Result, service_dispatcher};

use windows_service::service_manager::{ServiceManager, ServiceManagerAccess}

use windows_service::service::ServiceControl;
use windows_service::service_control_handler::{self, ServiceControlHandlerResult};

define_windows_service!(ffi_service_main, my_service_main);

fn my_service_main(arguments: Vec<OsString>) {
    // The entry point where execution will start on a background thread after a call to
    // `service_dispatcher::start` from `main`.
    if let Err(_e) = run_service(arguments) {
        // Handle errors in some way.
    }
}

fn run_service(arguments: Vec<OsString>) -> Result<()> {
    let event_handler = move |control_event| -> ServiceControlHandlerResult {
        match control_event {
            ServiceControl::Stop => {
                // Handle stop event and return control back to the system.
                ServiceControlHandlerResult::NoError
            }
            // All services must accept Interrogate even if it's a no-op.
            ServiceControl::Interrogate => ServiceControlHandlerResult::NoError,
            _ => ServiceControlHandlerResult::NotImplemented,
        }
    };

    // Register system service event handler
    let status_handle = service_control_handler::register("myservice", event_handler)?;
    Ok(())
}

fn main() -> Result<()> {
    // Register generated `ffi_service_main` with the system and start the service, blocking
    // this thread until the service is stopped.

    
    let sc_manager = ServiceManager::local_computer(
        None::<&str>, 
        ServiceManagerAccess::all()
    )?;
    
    todo!("Figure out access rights for service manager connection");

    // sc_manager.create_service(service_info, service_access)

    
    service_dispatcher::start("myservice", ffi_service_main)?;
    
    Ok(())
}